# The functions in this script are used to create a potential field representing obstacles and to integrate a streamline solution through the field

import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import interp2d

# X component of velocity field generated by a source/sink
def u_source(x,y,source_center,Lambda):
    # x, y: velocity field is a function of x and y
    # source_center = (xc, yc): center coordinate of obstacle
    # Lambda: source stength (negative for a sink)
    xc,yc = source_center
    return Lambda*(x-xc)/(np.pi*np.sqrt((x-xc)**2+(y-yc)**2))

# Y component of velocity field generated by a source
def v_source(x,y,source_center,Lambda):
    # x, y: velocity field is a function of x and y
    # source_center = (xc, yc): center coordinate tuple of obstacle
    # Lambda: source stength (negative for a sink)
    xc,yc = source_center
    return Lambda*(y-yc)/(np.pi*np.sqrt((x-xc)**2+(y-yc)**2))

# X component of velocity field generated by a vortex
def u_vortex(x,y,source_center,Lambda):
    # x, y: velocity field is a function of x and y
    # source_center = (xc, yc): center coordinate of obstacle
    # Lambda: source stength (negative for a sink)
    xc,yc = source_center
    theta = np.arctan2(y-yc, x-xc)
    return np.sin(theta) * -Lambda/(2*np.pi*np.sqrt((x-xc)**2+(y-yc)**2))

# Y component of velocity field generated by a vortex
def v_vortex(x,y,source_center,Lambda):
    # x, y: velocity field is a function of x and y
    # source_center = (xc, yc): center coordinate tuple of obstacle
    # Lambda: source stength (negative for a sink)
    xc,yc = source_center
    theta = np.arctan2(y-yc, x-xc)
    return -np.cos(theta) * -Lambda/(np.pi*np.sqrt((x-xc)**2+(y-yc)**2))

def detect_collision(xs, ys, obst, safe_factor):
    xc, yc, r = obst
    dist = np.sqrt((xs - xc)**2 + (ys - yc)**2)
    min_dist = np.amin(dist)

    is_collide = False
    if min_dist <= r + safe_factor:
        is_collide = True

    a = np.array([xs[np.argmin(dist[:-1])] - xc, ys[np.argmin(dist[:-1])] - yc])
    b = np.array([xs[np.argmin(dist[:-1])+1] - xs[np.argmin(dist[:-1])], ys[np.argmin(dist[:-1])+1] - ys[np.argmin(dist[:-1])]])
    direction = np.sign(np.cross(a,b)) # -1 cw, +1 ccw

    return is_collide, min_dist, direction

def calc_streamline(XX, YY, U, V, start, goal):
    x = XX[0,:]
    y = YY[:,0]

    fU = interp2d(x, y, U)
    fV = interp2d(x, y, V)
    
    iter_limit = 1000
    xs = np.zeros(iter_limit)
    ys = np.zeros(iter_limit)
    u = np.zeros(iter_limit)
    v = np.zeros(iter_limit)
    xs[0], ys[0] = start
    xf, yf = goal

    i = 0;
    while (i < iter_limit-1):
        u[i] = fU(xs[i], ys[i])   # x component of velocity
        v[i] = fV(xs[i], ys[i])   # y-component of velocity

        rate = 1e-2
        xs[i+1] = xs[i] + u[i] * rate
        ys[i+1] = ys[i] + v[i] * rate
        dist = np.sqrt((xf - xs[i+1])**2 +  (yf - ys[i+1])**2)
        i += 1
        
        if dist < 1e-1:
            break;
        
    tf = i*rate
    return xs[:i], ys[:i], tf

# Same function as above, but uses rk4 instead of Euler
def calc_streamline_rk4(XX, YY, U, V, start, goal):
    x = XX[0,:]
    y = YY[:,0]

    fU = interp2d(x, y, U)
    fV = interp2d(x, y, V)

    f = lambda r: np.array([fU(r[0], r[1]), fV(r[0], r[1])])
    
    iter_limit = 2500
    xs = np.zeros(iter_limit)
    ys = np.zeros(iter_limit)
    xs[0], ys[0] = start
    xf, yf = goal
    r = np.array([xs[0], ys[0]])  # initial condition

    i = 0;
    h = 1e-1
    while (i < iter_limit-1):
        k1 = h*f(r)[:,0]
        k2 = h*f(r+0.5*k1)[:,0]
        k3 = h*f(r+0.5*k2)[:,0]
        k4 = h*f(r+k3)[:,0]
        r += (k1+2*k2+2*k3+k4)/6
        xs[i+1] = r[0]   # next point in trajectory
        ys[i+1] = r[1]   # next point in trajectory
        dist = np.sqrt((xf - xs[i+1])**2 +  (yf - ys[i+1])**2)
        i += 1
        if dist < 1.75:
            break;
        
    tf = i*h

    return xs[:i], ys[:i], tf


def potential_path(XX, YY, start, goal, obst_field, safe_factor):
    # start: xi,yi
    # goal: xf,yf
    # obstacle_field: circular obstacles, center coord and radius (xc,yc,r)

    x0, y0 = start
    xf, yf = goal

    U = np.zeros_like(XX)
    V = np.zeros_like(YY)

    # Uniform flow from start to goal
    v_inf = 0
    theta = 0
    U = v_inf * np.cos(theta)
    V = v_inf * np.sin(theta)

    # Add init sink at goal
    U += u_source(XX, YY, (xf, yf), -25)
    V += v_source(XX, YY, (xf, yf), -25)
    
    # Add obstacles
    Q = np.zeros(len(obst_field))
    collide = np.ones(len(obst_field))
    direction = np.ones(len(obst_field))
    
    iter_limit = 2500
    for _ in range(iter_limit):
        U_obst = U;
        V_obst = V;
        for i, obst in enumerate(obst_field):
            xc, yc, r = obst
            
            index = (i-1) % len(obst_field)
            xc_prev, yc_prev, _ = obst_field[index]
            U_obst += u_source(XX, YY, (xc_prev, yc_prev), Q[index])
            V_obst += v_source(XX, YY, (xc_prev, yc_prev), Q[index])
            U_obst += u_vortex(XX, YY, (xc_prev, yc_prev), 5*direction[index]*Q[index])
            V_obst += v_vortex(XX, YY, (xc_prev, yc_prev), 5*direction[index]*Q[index])

            xs, ys, tf = calc_streamline_rk4(XX, YY, U_obst, V_obst, start, goal)
            is_collide, min_dist, direction[i] = detect_collision(xs, ys, obst, safe_factor)

            if is_collide:
                Q[i] += (safe_factor + r - min_dist) * 1e-2
                collide[i] = 1
            else:
                collide[i] = 0

        if not any(collide):
            # print(Q)
            break

    return xs, ys, U, V, tf